from collections import OrderedDict
from datetime import datetime
from http import HTTPStatus
from unittest import TestCase
from unittest import main as unittest_main
from unittest.mock import Mock
from unittest.mock import patch as unittest_patch

from betamax import Betamax
from betamax.fixtures.unittest import BetamaxTestCase
from scrapy.http import HtmlResponse
from scrapy.spidermiddlewares.httperror import HttpError
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from twisted.internet.error import TimeoutError
from twisted.python.failure import Failure
from twisted.trial import unittest as twisted_unittest

from realtor_com.models import Property, create_database_connection, create_tables
from realtor_com.pipelines import PropertyscraperPipeline
from realtor_com.spiders.base import request_headers
from realtor_com.spiders.property import PropertySpider

# Configure Betamax
with Betamax.configure() as config:
    config.cassette_library_dir = "realtor_com/tests/cassettes"
    config.preserve_exact_body_bytes = True


class TestPropertySpider(BetamaxTestCase):
    def test_parse_results(self):
        # Create a Scrapy Request object with headers
        property_spider = PropertySpider()
        url = "https://www.realtor.com/realestateandhomes-search/tampa_fl"

        # Mock response.follow to prevent actual requests
        with unittest_patch("scrapy.http.HtmlResponse.follow") as mock_follow:
            mock_follow.return_value = []

            # Run the spider with the mocked response.follow
            with self.recorder.use_cassette("test_property_cassette"):
                response = self.session.get(url=url, headers=request_headers)

                # Create a Scrapy Response object from the request session
                scrapy_response = HtmlResponse(
                    url=response.url, body=response.content, encoding="utf-8"
                )

                # Run the parse method
                result = property_spider.parse_results(scrapy_response)
                result_list = list(result)

                # Filter empty items generated by the mock_follow
                filter_list = [item for item in result_list if item != []]

                # Check the parse result type of the items returned
                for item in filter_list:
                    self.assertIsInstance(item, OrderedDict)

                # Check the parse result structure
                yield_keys = [
                    "data_id",
                    "url",
                    "media_img",
                    "status",
                    "price",
                    "beds",
                    "baths",
                    "sqft",
                    "sqftlot",
                    "address",
                    "city",
                    "state",
                    "zip_code",
                    "scraped_date_time",
                ]
                try:
                    result_keys = list(filter_list[0].keys())
                except IndexError:
                    result_keys = []

                self.assertEqual(yield_keys, result_keys)
                self.assertEqual(len(yield_keys), len(result_keys))


@unittest_patch("realtor_com.models.dotenv_values")
@unittest_patch("realtor_com.models.get_project_settings")
@unittest_patch("realtor_com.models.create_engine")
class TestCreateDatabaseConnection(TestCase):
    def test_create_database_connection(
        self, mock_create_engine, mock_get_project_settings, mock_dotenv_values
    ):
        # Set up mocks and test data
        mock_env = {"POSTGRES_URL": "test_db_url"}
        mock_dotenv_values.return_value = mock_env
        mock_project_settings = {"REALTOR_POSTGRES_URL_LOCAL": "test_db_url"}
        mock_get_project_settings.return_value = mock_project_settings

        # Perform the test
        engine = create_database_connection()

        # Assertions
        mock_dotenv_values.assert_called_once_with(".env")
        mock_get_project_settings.assert_called_once()
        mock_create_engine.assert_called_once_with(
            "test_db_url", pool_size=30, max_overflow=0
        )
        self.assertEqual(engine, mock_create_engine.return_value)

    def test_create_database_connection_missing_url(
        self, mock_create_engine, mock_get_project_settings, mock_dotenv_values
    ):
        # Set up mocks and test data
        mock_env = {"POSTGRES_URL": None}
        mock_dotenv_values.return_value = mock_env
        mock_project_settings = {"REALTOR_POSTGRES_URL_LOCAL": None}
        mock_get_project_settings.return_value = mock_project_settings

        # Perform the test
        with self.assertRaises(ValueError):
            create_database_connection()

            # Assertions
            mock_dotenv_values.assert_called_once_with(".env")
            mock_get_project_settings.assert_called_once()
            mock_create_engine.assert_not_called()


class TestCreateTables(TestCase):
    def setUp(self) -> None:
        # Set up sqlite mock engine
        self.mock_engine = create_engine("sqlite:///:memory:")

    @unittest_patch("realtor_com.models.DeclarativeBase.metadata.create_all")
    def test_create_tables(self, mock_create_all):
        # Perform the test
        create_tables(self.mock_engine)

        # Assertions
        mock_create_all.assert_called_once_with(self.mock_engine)

    @unittest_patch("realtor_com.models.DeclarativeBase.metadata.create_all")
    def test_create_tables_with_exception(self, mock_create_all):
        # Simulate an exception being raised during create_all
        mock_create_all.side_effect = Exception("Test exception")

        # Perform the test
        with self.assertRaises(Exception):
            create_tables(self.mock_engine)

            # Assertions
            mock_create_all.assert_called_once_with(self.mock_engine)


class TestPropertyscraperPipelineInit(TestCase):
    @unittest_patch("realtor_com.pipelines.sessionmaker")
    def test_init(self, mock_sessionmaker):
        # Set up mocks and test data
        mock_engine = create_engine("sqlite:///:memory:")
        mock_sessionmaker.return_value = mock_engine

        # Perform the test
        pipeline = PropertyscraperPipeline()

        # Assertions
        self.assertIsNotNone(pipeline.session)

    @unittest_patch("realtor_com.pipelines.create_database_connection")
    def test_init_with_value_error(self, mock_create_database_connection):
        # Set up mocks to raise a ValueError
        mock_create_database_connection.side_effect = ValueError("Test value error")
        with self.assertLogs(level="ERROR") as error_log_context:
            # Perform the test
            PropertyscraperPipeline()

            # Assertions
            self.assertEqual(len(error_log_context.output), 1)
            self.assertIn("Database connection problem:", error_log_context.output[0])

    @unittest_patch("realtor_com.pipelines.logger")
    @unittest_patch("realtor_com.pipelines.create_database_connection")
    def test_init_with_exception(self, mock_logger, mock_create_database_connection):
        # Set up mocks to raise an Exception
        mock_create_database_connection.side_effect = Exception("Test exception")
        with self.assertRaises(Exception) as exception_context:
            # Perform the test
            PropertyscraperPipeline()

            # Assertions
            mock_logger.exception.assert_called_once_with(exception_context.exception)


class TestPropertyscraperPipelineProcess(TestCase):
    @unittest_patch("realtor_com.pipelines.sessionmaker")
    def setUp(self, mock_sessionmaker) -> None:
        # Set up mock objects and test data
        mock_engine = create_engine("sqlite:///:memory:")
        create_tables(mock_engine)
        mock_sessionmaker.return_value = sessionmaker(bind=mock_engine)
        self.pipeline = PropertyscraperPipeline()
        self.test_item_data = {
            "data_id": 1,
            "url": "http://example.com",
            "media_img": "",
            "status": "",
            "price": "",
            "beds": "",
            "baths": "",
            "sqft": 1,
            "sqftlot": 1,
            "address": "",
            "city": "",
            "state": "",
            "zip_code": "",
            "scraped_date_time": datetime.now(),
        }
        self.mock_spider = Mock()

    def test_process_item_new_item(self):
        with self.pipeline.session() as test_session:
            # Assert that there is no data in the test database
            self.assertEqual(
                test_session.query(Property)
                .filter_by(
                    data_id=self.test_item_data["data_id"],
                    address=self.test_item_data["address"],
                    city=self.test_item_data["city"],
                    state=self.test_item_data["state"],
                    zip_code=self.test_item_data["zip_code"],
                )
                .first(),
                None,
            )

            # Perform the test
            self.pipeline.process_item(self.test_item_data, self.mock_spider)

            # Assertions
            self.assertEqual(len(self.pipeline.scraped_items), 1)

    def test_process_item_same_item(self):
        # Perform the test
        self.pipeline.process_item(self.test_item_data, self.mock_spider)
        self.assertEqual(len(self.pipeline.scraped_items), 1)

        # Run again the test
        self.pipeline.process_item(self.test_item_data, self.mock_spider)
        self.assertEqual(len(self.pipeline.scraped_items), 1)

    def test_process_item_existing(self):
        # Process the test item data and save to the database
        self.pipeline.process_item(self.test_item_data, self.mock_spider)
        self.pipeline.close_spider(self.mock_spider)

        # Perform the test
        self.pipeline.process_item(self.test_item_data, self.mock_spider)
        self.assertEqual(len(self.pipeline.scraped_items), 0)

    def test_close_spider(self):
        with self.pipeline.session() as test_session:
            # Process the test item data and save to the database
            self.pipeline.process_item(self.test_item_data, self.mock_spider)
            self.pipeline.close_spider(self.mock_spider)

            # Query the test item data
            first_item = (
                test_session.query(Property)
                .filter_by(
                    data_id=self.test_item_data["data_id"],
                    address=self.test_item_data["address"],
                    city=self.test_item_data["city"],
                    state=self.test_item_data["state"],
                    zip_code=self.test_item_data["zip_code"],
                )
                .all()
            )

            # Assertions
            self.assertNotEqual(first_item, None)
            self.assertEqual(len(first_item), 1)
            self.assertEqual(first_item[0].data_id, 1)

    @unittest_patch("realtor_com.pipelines.logger")
    @unittest_patch("realtor_com.pipelines.RealtorscraperPipeline.session")
    def test_close_spider_with_exception(self, mock_session, mock_logger):
        # Simulate an exception being raised during the session actions
        mock_session.side_effect = Exception("Test exception")

        # Execute the method and capture the raised exception
        with self.assertRaises(Exception) as exception_context:
            # Perform the test
            self.pipeline.process_item(self.test_item_data, self.mock_spider)
            self.pipeline.close_spider(self.mock_spider)

            # Assertions
            mock_session.assert_called_once()  # Session is created
            mock_logger.info.assert_called_once_with(
                "Saving events in bulk operation to the database..."
            )
            mock_session.return_value.bulk_save_objects.assert_called_once_with(
                self.pipeline.scraped_items
            )
            mock_session.return_value.commit.assert_not_called()  # Exception prevents commit
            mock_session.return_value.rollback.assert_called_once()  # Rollback is called
            mock_logger.exception.assert_called_once_with(
                exception_context.exception, extra={"spider": self.mock_spider}
            )
            mock_session.return_value.close.assert_called_once()  # Session is closed


class TestHandleError(twisted_unittest.TestCase):
    def setUp(self):
        self.property_spider = PropertySpider()
        self.test_url = "https://response.com"

    @unittest_patch("realtor_com.spiders.property.logger")
    def test_handle_403_error(self, mock_logger):
        # Simulate a 403 (Forbidden) HTTP error
        failure = Failure(
            HttpError(
                HtmlResponse(
                    url=self.test_url,
                    status=HTTPStatus.FORBIDDEN,
                    encoding="utf-8",
                )
            )
        )

        # Call the handle_error method
        self.property_spider.handle_error(failure)

        # Assertions
        mock_logger.warning.assert_called_once_with(
            "Skipping URL due to 403 error: %s", self.test_url
        )

    @unittest_patch("realtor_com.spiders.property.logger")
    def test_handle_other_http_error(self, mock_logger):
        # Simulate a 429 (Too Many Requests) HTTP error
        failure = Failure(
            HttpError(
                HtmlResponse(
                    url=self.test_url,
                    status=HTTPStatus.TOO_MANY_REQUESTS,
                    encoding="utf-8",
                )
            )
        )

        # Call the handle_error method
        self.property_spider.handle_error(failure)

        # Assertions
        mock_logger.error.assert_called_once_with(
            "Error processing URL: %s", self.test_url
        )

    @unittest_patch("realtor_com.spiders.property.logger")
    def test_handle_other_error(self, mock_logger):
        failure = Failure(TimeoutError(self.test_url))

        # Call the handle_error method
        self.property_spider.handle_error(failure)

        # Assertions
        error_message = f"User timeout caused connection failure: {self.test_url}."
        mock_logger.error.assert_called_once_with(error_message)


if __name__ == "__main__":
    unittest_main()
